# ==============================================================================
# FastAPI在庫管理システム - Dockerfile (学習用コメント版)
# ==============================================================================
# このDockerfileは、FastAPIアプリケーションをコンテナ化するための設定ファイルです。
# Dockerイメージをビルドする際の手順を定義しています。

# ------------------------------------------------------------------------------
# 1. ベースイメージの選択
# ------------------------------------------------------------------------------
# FROM命令: Dockerイメージのベースとなるイメージを指定
# python:3.11-slim を選択する理由：
# - python:3.11 - Python 3.11の公式イメージ
# - slim - 軽量版（最小限のパッケージのみ含む）
# - 通常のpython:3.11と比較して約200MB軽量
# - 本番環境では軽量なイメージが推奨される
FROM python:3.11-slim

# ------------------------------------------------------------------------------
# 2. 作業ディレクトリの設定
# ------------------------------------------------------------------------------
# WORKDIR命令: コンテナ内での作業ディレクトリを設定
# 以降のCOPY、RUN、CMDなどのコマンドはこのディレクトリで実行される
# /app を選ぶ理由：
# - 一般的な慣習（多くのDockerfileで使用される）
# - システムディレクトリと衝突しない
# - シンプルで覚えやすい
WORKDIR /app

# ------------------------------------------------------------------------------
# 3. 依存関係ファイルのコピー
# ------------------------------------------------------------------------------
# COPY命令: ホスト（ローカル）からコンテナへファイルをコピー
# requirements.txt . の意味：
# - requirements.txt: コピー元ファイル（ホスト側）
# - . : コピー先ディレクトリ（コンテナ側の現在のディレクトリ = /app）
# なぜ最初にrequirements.txtだけコピーするのか：
# - Dockerのレイヤーキャッシュを活用するため
# - ソースコードが変更されても、依存関係が変わらなければキャッシュが使える
# - ビルド時間の短縮につながる
COPY requirements.txt .

# ------------------------------------------------------------------------------
# 4. Python依存関係のインストール
# ------------------------------------------------------------------------------
# RUN命令: コンテナ内でコマンドを実行
# pip install の各オプションの説明：
# - pip: Pythonのパッケージマネージャー
# - install: パッケージをインストールする
# - --no-cache-dir: pipのキャッシュを使用しない
#   理由：コンテナイメージサイズを小さく保つため
#   キャッシュはコンテナが削除されると消えるので意味がない
# - -r requirements.txt: requirements.txtファイルから依存関係を読み込む
RUN pip install --no-cache-dir -r requirements.txt

# ------------------------------------------------------------------------------
# 5. アプリケーションコードのコピー
# ------------------------------------------------------------------------------
# COPY . . の意味：
# - 最初の . : ホスト側の現在のディレクトリ（プロジェクトルート）
# - 2番目の . : コンテナ側の現在のディレクトリ（/app）
# なぜ requirements.txt の後にソースコードをコピーするのか：
# - Dockerレイヤーの最適化のため
# - ソースコード変更時も依存関係のインストール層はキャッシュされる
# .dockerignore ファイルがあれば、指定されたファイル/ディレクトリは除外される
COPY . .

# ------------------------------------------------------------------------------
# 6. ポートの公開設定
# ------------------------------------------------------------------------------
# EXPOSE命令: コンテナが使用するポートを宣言
# 注意：実際にはポートを公開しない（ドキュメント的な意味）
# 実際の公開は docker run -p や docker-compose.yml で行う
# 8000: FastAPI（uvicorn）が使用するポート
#   - FastAPIのデフォルトポート
#   - Webアプリケーションのメインエントリーポイント
# 5678: debugpy（Pythonデバッガー）が使用するポート
#   - VSCodeなどのエディタからリモートデバッグするため
#   - 開発環境でのみ必要（本番環境では不要）
EXPOSE 8000 5678

# ------------------------------------------------------------------------------
# 7. コンテナ起動時のコマンド定義
# ------------------------------------------------------------------------------
# CMD命令: コンテナ起動時に実行されるデフォルトコマンド
# JSON配列形式（exec form）を使用することで、シェルを経由せずに直接実行
# 各パラメータの詳細説明：

# python: Pythonインタープリター
# -m: モジュールを実行（python -m module_name の形式）

# debugpy: Pythonのリモートデバッグライブラリ
#   - VSCodeなどのエディタからコンテナ内のPythonプロセスをデバッグ可能
#   - --listen 0.0.0.0:5678: 全てのネットワークインターフェースの5678ポートで待機
#     - 0.0.0.0: 全てのIPアドレスからの接続を受け入れ
#     - 5678: デバッグ用のポート番号

# uvicorn: ASGI（Asynchronous Server Gateway Interface）サーバー
#   - FastAPIアプリケーションを実行するためのWebサーバー
#   - 非同期処理に対応
#   - 高パフォーマンス

# api.main:app: アプリケーションの指定
#   - api.main: api/main.py ファイルを指す
#   - app: main.py内のFastAPIインスタンス変数名

# --host 0.0.0.0: バインドするホストアドレス
#   - デフォルトは127.0.0.1（localhost）
#   - 0.0.0.0にすることでコンテナ外からのアクセスを許可

# --port 8000: バインドするポート番号
#   - FastAPIアプリケーションが待機するポート

# --reload: ファイル変更時の自動リロード
#   - 開発時に便利な機能
#   - ソースコード変更時にサーバーが自動的に再起動
#   - 本番環境では使用しない（パフォーマンスに影響）
CMD ["python", "-m", "debugpy", "--listen", "0.0.0.0:5678", "-m", "uvicorn", "api.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

# ==============================================================================
# Dockerfileのベストプラクティス
# ==============================================================================
# 1. レイヤーの最適化：
#    - 変更頻度の低いものから順にCOPY/RUN
#    - .dockerignoreでキャッシュを活用
# 
# 2. セキュリティ：
#    - 本番環境では--reloadオプションを削除
#    - 本番環境ではデバッグポート（5678）を公開しない
#    - rootユーザーではなく専用ユーザーで実行を推奨
# 
# 3. サイズ最適化：
#    - slimイメージの使用
#    - --no-cache-dirオプションの使用
#    - 不要なファイルの除外（.dockerignore）
# 
# 4. マルチステージビルド：
#    - より複雑なアプリケーションでは検討
#    - ビルド用とランタイム用でイメージを分離
# ==============================================================================